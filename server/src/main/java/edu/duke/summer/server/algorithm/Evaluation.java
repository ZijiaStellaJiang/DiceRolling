/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package edu.duke.summer.server.algorithm;

import edu.duke.summer.server.algorithm.value.IntValue;
import edu.duke.summer.server.algorithm.value.Value;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Random;

public class Evaluation {
    public static void main(String[] args) {
        HashMap<String, Value> vars = new HashMap<>();
        vars.put("invisible", new IntValue(1));
        new EvalServicempl().evalRoll("invisible?d30+2:(d30+1)", vars, new Random());

        new EvalServicempl().saveRules("\n" +
                "{ type rollwithmod {\n" +
                "    numdice:int,\n" +
                "    numsides:int,\n" +
                "    modifier:int\n" +
                "    }\n" +
                " type attack {\n" +
                "    basedmg: rollwithmod,\n" +
                "    attackbon: int,\n" +
                "    rerolls: int,\n" +
                "    critthreat: int,\n" +
                "    autoconfirm: boolean,\n" +
                "    addoncrit : rollwithmod,\n" +
                "    addonsneak: rollwithmod,\n" +
                "    addoncritsneak:rollwithmod\n" +
                "    }\n" +
                "type buff{\n" +
                "    name: string,\n" +
                "    amount: int,\n" +
                "    active: boolean\n" +
                " }\n" +
                "type creature{\n" +
                "    attacks: attack [],\n" +
                "    attackbuffs: buff [],\n" +
                "    ac: int,\n" +
                "    missChance: int,\n" +
                "    critreduce: int,\n" +
                "    sneakreduce: int,\n" +
                "    hascritnegate :boolean,\n" +
                "    hassneaknegate:boolean,\n" +
                "    sritovercome:int,\n" +
                "    sneakovercome:int,\n" +
                "    canAddReroll: boolean,\n" +
                "    rerollbonus: int,\n" +
                "    canForceReroll: boolean,\n" +
                "    forcererollpen: int\n" +
                "    }\n" +
                "fun int rollwithmod(rollwithmod r) {\n" +
                "        var ans = roll(r.numdice + \"d\" + r.numsides); \n" +
                "        return ans + r.modifier;\n" +
                "    }\n" +
                "fun int oneAttack(creature target, creature attacker, attack whichattack, boolean couldsneak) {\n" +
                "    var tohit = roll(\"d20\");\n" +
                "    var recount = whichattack.rerolls;\n" +
                "    var abon=whichattack.attackbon;\n" +
                "    for (b : attacker.attackbuffs){\n" +
                "     if (b.active) then {\n" +
                "        abon = abon + b.amount;\n" +
                "      }\n" +
                "   }\n" +
                "    if (attacker.canAddReroll) then {\n" +
                "       if (oneUserOption (attacker,\"Reroll?\")) then{               \n" +
                "             recount = recount + 1;\n" +
                "             abon = abon + rerollbonus;\n" +
                "        }\n" +
                "    }\n" +
                "     if (target.canForceReroll) then {\n" +
                "         if (oneUserOption(target, \"Force Reroll?\")) then {  \n" +
                "              recount = recount - 1;\n" +
                "              abon = abon - forcererollpen;\n" +
                "         }\n" +
                "   }\n" +
                "     while (recount > 0) {\n" +
                "        var temp = roll(\"d20\");\n" +
                "        tohit = max(temp, tohit);\n" +
                "        recount = recount - 1;\n" +
                "    }\n" +
                "    while(recount <0){ \n" +
                "        var temp = roll(\"d20\");\n" +
                "        tohit = min(temp, tohit);\n" +
                "    }\n" +
                "    if(tohit == 1) then{ \n" +
                "        output(\"Miss (natural 1)\");\n" +
                "        return 0;\n" +
                "    }\n" +
                "    if (tohit != 20 && tohit + abon < target.ac) then{\n" +
                "        output(\"Miss (AC)\");\n" +
                "        return 0;\n" +
                "    }\n" +
                "    if (roll(d100) <= target.missChance) then{\n" +
                "        output (\"Miss (miss chance)\");\n" +
                "        return 0;\n" +
                "    }\n" +
                "    var crit = false;\n" +
                "    if (tohit >= whichattack.critthreat) then {\n" +
                "        if (whichattack.autoconf || roll(\"d20\") + abon >= target.ac) then{\n" +
                "            if( roll(\"d100\") > target.critReduce) then{\n" +
                "                if (!target.hascritnegate || !userOption(\"Negate Crit?\")) then{ \n" +
                "                    crit = true;\n" +
                "                }       \n" +
                "             }\n" +
                "           }\n" +
                "        }\n" +
                "   var sneak = couldSneak && roll(\"d100\") > target.sneakReduce && (!target.hassneaknegate || !userOption(\"Negate Sneak Attack?\"));\n" +
                "   var dmg = rollwithmod(whichattack.basedmg);\n" +
                "   var descr =\"Hit\";\n" +
                "   if (sneak) then{\n" +
                "        dmg = dmg + rollwithmod(whichattack.addonsneak);\n" +
                "        descr = \"Sneak Attack\";\n" +
                "    }\n" +
                "   if (crit) then{\n" +
                "        dmg = dmg + rollwithmod(whichattack.addoncrit);\n" +
                "        descr = \"Critical Hit\";\n" +
                "    }\n" +
                "    if (crit && sneak) then{\n" +
                "        dmg = dmg + rollwithmod(whichattakc.addoncritsneak);\n" +
                "        descr = \"Critical Sneak Attack\";\n" +
                "    }\n" +
                "    output(descr + dmg); \n" +
                "    return dmg;         \n" +
                "    }\n" +
                "}");

        RuleInfo info = new EvalServicempl().saveRules("{type rollwithmod {\n" +
                "    numdice:int,\n" +
                "    numsides:int option option [],\n" +
                "    modifier:int [][][] option\n" +
                "    }\n" +
                " type test = rollwithmod;\n" +
                " type newType {\n" +
                "    a:test,\n" +
                "    b:string option [] option,\n" +
                "    c:boolean option []\n" +
                "    }\n" +
                " fun int cal(int a){\n" +
                "    var b = 0;\n" +
                "    var anArray:int [] = {1};\n" +
                "    var sum = 0;\n" +
                "    var opti: int option;\n" +
                "    var userTest : newType;\n" +
                "    userTest.a.numdice = 5;\n" +
                "    opti = SOME(1);\n" +
                "    opti = NONE;\n" +
                "    anArray = {1,2,3,7,10};\n" +
                "    anArray[3] = 10;\n" +
                "    output(a);\n" +
                "    for(i : anArray){\n" +
                "        sum = sum + i;\n" +
                "        if (sum > 10) then { return sum;}\n" +
                "    }\n" +
                "    a = 1;\n" +
                "    output(a);\n" +
                "    return sum;\n" +
                "    }\n" +
                "   \n" +
                "    fun int test(int i){\n" +
                "        i = 1;\n" +
                "        while(i < 10){\n" +
                "            i = i + 1;\n" +
                "        }\n" +
                "        return i;\n" +
                "    }\n" +
                "    fun int testCallExp(){\n" +
                "        var i = test(20);\n" +
                "        return i;\n" +
                "    }\n" +
                "    fun int testRoll(){\n" +
                "        var i = roll(\"d100\");\n" +
                "        if(userOption(\"Reroll?\")) then{\n" +
                "            var i = 1;\n" +
                "            output(i);\n" +
                "        }\n" +
                "        if(i > 1) then {\n" +
                "            output(\"roll:\" + roll(\"3d4\"));\n" +
                "        }else{\n" +
                "            var i = roll(\"d100\");   \n" +
                "            output(i);\n" +
                "        }\n" +
                "        output(\"force reroll\");\n" +
                "        return i;\n" +
                "   }\n" +
                "}");

        HashMap<String, Value> params = new HashMap<>();

        HashMap<String, Value> params1 = new HashMap<>();
        HashMap<String, Value> params2 = new HashMap<>();
        IntValue value = new IntValue(10);
        IntValue value1 = new IntValue(20);
        params.put("a", value);
        params1.put("i", value1);
        FuncCallResult res = info.getFuncs().get("cal").getResult(params, new StateInfo());
        Value returnValue = res.getVal();
        FuncCallResult res1 = info.getFuncs().get("test").getResult(params1, new StateInfo());
        FuncCallResult res2 = info.getFuncs().get("testCallExp").getResult(params2, new StateInfo());
        StateInfo state = new StateInfo();
        state.addTrueUserOption("ru");
        FuncCallResult res3 = info.getFuncs().get("testRoll").getResult(params2, state);
        System.out.println("----finalResult----");
//        System.out.println(((IntValue)returnValue).getValue());
//        System.out.println(((IntValue)res1.val).getValue());
//        System.out.println(((IntValue)res2.val).getValue());
        System.out.println(((IntValue)res3.val).getValue());
        res3.printInfo();
        ArrayList<String> outputs = res3.getOutput();
        System.out.println("----outputMsg----");
        for(String str : outputs){
            System.out.println(str);
        }

    }
}
